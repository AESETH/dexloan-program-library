import * as splToken from "@solana/spl-token";
import * as anchor from "@project-serum/anchor";
import {
  useConnection,
  useWallet,
  useAnchorWallet,
  AnchorWallet,
} from "@solana/wallet-adapter-react";
import { PhantomWalletName } from "@solana/wallet-adapter-wallets";
import { Metadata } from "@metaplex-foundation/mpl-token-metadata";
import bs58 from "bs58";
import type { NextPage } from "next";
import Head from "next/head";
import Image from "next/image";
import styles from "../styles/Home.module.css";
import idl from "../target/idl/dexloan.json";
import type { Dexloan } from "../target/types/dexloan";
import { useEffect } from "react";
import { useQuery } from "react-query";

const Home: NextPage = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const anchorWallet = useAnchorWallet();

  const nftQuery = useQuery(
    ["wallet-nfts", wallet.publicKey?.toBase58()],
    () => {
      if (anchorWallet) {
        return getNFTs(connection, anchorWallet);
      }
    },
    { enabled: Boolean(anchorWallet?.publicKey) }
  );

  console.log(nftQuery);

  useEffect(() => {
    if (anchorWallet?.publicKey) {
      getNFTs(connection, anchorWallet);
    }
  }, [connection, anchorWallet]);

  useEffect(() => {
    wallet.select(PhantomWalletName);
  }, [wallet]);

  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}></main>

      <footer className={styles.footer}>
        <a
          href="https://vercel.com?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          Powered by{" "}
          <span className={styles.logo}>
            <Image src="/vercel.svg" alt="Vercel Logo" width={72} height={16} />
          </span>
        </a>
      </footer>
    </div>
  );
};

export default Home;

async function getNFTs(
  connection: anchor.web3.Connection,
  wallet: AnchorWallet
) {
  const tokenAccounts = await connection.getTokenAccountsByOwner(
    wallet.publicKey,
    {
      programId: splToken.TOKEN_PROGRAM_ID,
    }
  );

  return Promise.all(tokenAccounts.value.map(decodeAccountInfo))
    .then((accounts) => accounts.filter((info) => info.amount.toNumber() === 1))
    .then((accounts) =>
      Promise.all(accounts.map((account) => loadMetadata(connection, account)))
    )
    .then((results) => results.filter(Boolean));
}

async function decodeAccountInfo({
  pubkey,
  account,
}: {
  pubkey: anchor.web3.PublicKey;
  account: anchor.web3.AccountInfo<Buffer>;
}) {
  const accountInfo = splToken.AccountLayout.decode(account.data);

  accountInfo.address = pubkey;
  accountInfo.mint = new anchor.web3.PublicKey(accountInfo.mint);
  accountInfo.owner = new anchor.web3.PublicKey(accountInfo.owner);
  accountInfo.amount = splToken.u64.fromBuffer(accountInfo.amount);

  return accountInfo;
}

async function loadMetadata(
  connection: anchor.web3.Connection,
  accountInfo: any
) {
  try {
    const metadataPDA = await Metadata.getPDA(accountInfo.mint);
    const metadata = await Metadata.load(connection, metadataPDA);
    return {
      accountInfo,
      metadata,
    };
  } catch {
    // Ignore
  }
}

async function getListings(
  program: anchor.Program<Dexloan>,
  state: number = 0
) {
  return program.account.listing.all([
    {
      memcmp: {
        offset: 0,
        bytes: bs58.encode(Buffer.from([state])),
      },
    },
  ]);
}

function getProgram(provider: anchor.Provider): anchor.Program<Dexloan> {
  const programID = new anchor.web3.PublicKey(idl.metadata.address);
  return new anchor.Program(idl as any, programID, provider);
}

function getProvider(
  connection: anchor.web3.Connection,
  wallet: typeof anchor.Wallet
): anchor.Provider {
  return new anchor.Provider(
    connection,
    wallet,
    anchor.Provider.defaultOptions()
  );
}
